//
// position.h (rewritten)
// Correct position accounting with realized PnL and safe lookups.
//
// Notes:
// - This version is long-only by default. Sell orders cannot exceed holdings.
// - Average cost is updated ONLY when increasing a long position.
// - Reducing/closing a long position realizes PnL = (sell_price - avg_cost) * closed_qty
//
#ifndef BACKTEST_POSITION_H
#define BACKTEST_POSITION_H

#include <string>
#include <unordered_map>
#include <algorithm>
#include <cmath>

// Enhanced order types (kept same enum values as your original code)
enum class OrderType {
    MarketBuy,
    MarketSell,
    LimitBuy,
    LimitSell,
    StopLossBuy,
    StopLossSell
};

enum class Side { Buy, Sell };

inline constexpr Side order_side(OrderType t) noexcept {
    switch (t) {
        case OrderType::MarketBuy:
        case OrderType::LimitBuy:
        case OrderType::StopLossBuy:
            return Side::Buy;
        default:
            return Side::Sell;
    }
}

// Single trade fill generated by EnhancedTradingEngine
struct EnhancedTrade {
    std::string timestamp;       // user-provided timestamp
    std::string symbol;
    OrderType order_type;
    double requested_price = 0.0;
    double executed_price = 0.0;
    int executed_quantity = 0;

    double commission_rate = 0.0;
    double commission = 0.0;
    double slippage_rate = 0.0;  // for reporting only

    std::string position_effect; // open/increase/reduce/close (best-effort)

    EnhancedTrade(std::string ts,
                  std::string sym,
                  OrderType type,
                  double req_price,
                  double exec_price,
                  int qty,
                  double comm_rate,
                  double slip_rate,
                  std::string effect)
            : timestamp(std::move(ts)),
              symbol(std::move(sym)),
              order_type(type),
              requested_price(req_price),
              executed_price(exec_price),
              executed_quantity(qty),
              commission_rate(comm_rate),
              slippage_rate(slip_rate),
              position_effect(std::move(effect)) {

        commission = std::abs(executed_price * executed_quantity) * commission_rate;
    }
};

// Per-symbol position
struct Position {
    std::string symbol;
    int total_quantity = 0;    // long shares
    double avg_cost = 0.0;     // average entry cost for remaining shares

    double realized_pnl = 0.0; // realized profit/loss from closed shares

    // Apply fill and return realized pnl delta (price-diff component only).
    // signed_qty: +buy, -sell
    double apply_fill(int signed_qty, double fill_price) {
        if (signed_qty == 0) return 0.0;

        // BUY: increase long position, update avg cost (weighted)
        if (signed_qty > 0) {
            const int new_qty = total_quantity + signed_qty;
            if (new_qty <= 0) {
                // should not happen in long-only mode
                total_quantity = 0;
                avg_cost = 0.0;
                return 0.0;
            }
            avg_cost = (avg_cost * total_quantity + fill_price * signed_qty) / new_qty;
            total_quantity = new_qty;
            return 0.0;
        }

        // SELL: reduce/close long position, avg_cost stays unchanged for remaining
        const int sell_qty = -signed_qty;
        const int closed_qty = std::min(sell_qty, total_quantity);
        if (closed_qty <= 0) return 0.0;

        const double pnl_delta = (fill_price - avg_cost) * closed_qty;
        realized_pnl += pnl_delta;

        total_quantity -= closed_qty;
        if (total_quantity == 0) avg_cost = 0.0;

        // If sell_qty > closed_qty, engine validation should have prevented it.
        return pnl_delta;
    }
};

class PositionManager {
public:
    // Safe find (no exceptions). Returns nullptr if missing.
    const Position* find_position(const std::string& symbol) const noexcept {
        auto it = positions_.find(symbol);
        return (it == positions_.end()) ? nullptr : &it->second;
    }
    Position* find_position_mut(const std::string& symbol) noexcept {
        auto it = positions_.find(symbol);
        return (it == positions_.end()) ? nullptr : &it->second;
    }

    // Get or create
    Position& get_or_create(const std::string& symbol) {
        auto& p = positions_[symbol];
        p.symbol = symbol;
        return p;
    }

    // Process trade to update position. Returns realized pnl delta (price diff only).
    double process_trade(const EnhancedTrade& trade) {
        const int signed_qty = (order_side(trade.order_type) == Side::Buy)
                               ? +trade.executed_quantity
                               : -trade.executed_quantity;
        auto& pos = get_or_create(trade.symbol);
        return pos.apply_fill(signed_qty, trade.executed_price);
    }

    const std::unordered_map<std::string, Position>& all_positions() const noexcept { return positions_; }

private:
    std::unordered_map<std::string, Position> positions_;
};

#endif // BACKTEST_POSITION_H
